# robot-sol-dist-protocol
For the McCalla Lab at McGill. Built for an OT2 Robot using the Opentrons API. General protocol for a variety of solutions and distributions for high-throughput production of electrode materials.



**User Input Section**

The user input section contains a list of the commonly changed parameters for the code. The idea of this section is that it is the only part of the protocol that needs to be edited on a run-by-run basis. For this reason, it is placed at the top of the script for quick access. The parameters made available for quick edits are plate type, pipettes, solution distributions, and some key pipette settings.

**Plate Type**

The plate type parameter is given the variable name container_choice. The string input to this parameter should be one of the 3 available plates: ‘full_alumina’, ‘half_alumina’, or ‘cups’. Note that the ‘half_alumina’ plate cannot be used for the 2D gradient or parallelogram distributions since these distribution types require an 8x8 grid. 

**Pipettes**

The pipettes parameter is given the variable name current_pipettes. The input to this is a list of two integers. The first integer should refer to the pipette mounted on the left side of the robot arm, ie: ‘300’, ‘50’, or ‘10’. The second integer on the list should refer to the pipette mounted on the right. The desired use of the script is to always enter both pipettes mounted on the robot, even if the volume range used in your protocol will only require one of the pipettes. The script is designed to predetermine which pipettes will be used and will only ask for calibration of both pipettes if both pipettes are used for distribution. 

**Solution Distributions**

The solution distributions section of the user input is made for specifying how many solutions you have and how each one needs to be distributed across the plate. The variables used for solution distributions are ‘solution_A’, ‘solution_B’, …, and ‘precipitator’. The script will distribute these solutions in order from A to precipitator, with an exception for small volumes. The positions of these solutions are later defined to correspond with the wells labelled on the solution well plate. Note that there are only 5 solution variables listed in the user section, but theoretically infinite solutions could be listed as long as they are all subsequently defined. 

The input for the solution variables are different for every distribution type. Note that for all volume inputs, it should be in μl and as a integer or float type variable. 
For a solution with a constant volume across the plate, just write the volume as the only item in the list.
For a solution with a checkerboard distribution, first write the volume, then write the parity as a string as the second item in the list. 
For a solution with a one-dimensional volume gradient, write the starting volume as the first entry (top or left side of plate), the ending volume as the second entry (bottom or right side of plate), and the direction as a string. The direction should be either ‘x’, meaning left to right, or ‘y’, meaning top to bottom. Note that the protocol can accommodate both increasing and decreasing gradients. 
For a solution with a two-dimensional symmetrical volume gradient, the first entry in the list should be the starting volume (top left well), followed by the ending volume (bottom right well). The third entry in the list should be string ‘2D’, and the fourth entry should be the string ‘symm’. 
For a solution with a volume gradient corresponding to a parallelogram of a ternary diagram, the first entry in the list should be the largest volume in the gradient, and the second entry the lowest. The third entry should be the string ‘2D’, and the last two entries should be integers describing the diagonal direction across the plate from large volume to the small volume. The direction should be denoted with ±1 in the x direction, followed by ±1 in the y direction. For a diagram explaining the directions, see the section dedicated to the parallelogram distribution.

**Important Pipette Settings**

The pipette settings included in the user input section are those most likely to be changed commonly, but are not an exhaustive list of all of the settings. The settings are the minimum pipette volumes, the pipette dispense rate, and the small volume condition.
Minimum pipette volumes are set for the P300 and P50 using the variables ‘P300_min_volume’ and ‘P50_min_volume’ respectively. The input is the minimum volume in μl that the protocol will choose to use that pipette for.  The standard values for the P300 and P50 set by Opentrons are 30 μl and 5 μl respectively based on their construction.  In our protocol, the minimum volume parameter is chosen to be 1 μl greater than the maximum of the next smallest pipette. Hence, our standard is to have the P300 minimum volume set at 50.1 μl, so that the P50 may be chosen for 50 μl volumes and under, and the P50 minimum volume is set at 10.1μl so that the P10 may be chosen for 10μl volumes and under. This optimizes the precision of the robot without sacrificing time by requiring a small pipette to do multiple trips for a large volume. Note that this parameter should not be changed often, unless its most desirable to use the P300 and P10 as the two pipettes. In this instance, you may want to lower the minimum volume of the P300 to save time. Given a volume of over 10μl, the P10 will aspirate and dispense over multiple iterations of 10μl. This is an automatic feature of the Opentrons App and not something written into our protocol. 
The dispense rate settings for our three pipettes are given the name ‘P300_dispense_rate’, ‘P50_dispense_rate’, and ‘P10_dispense_rate’. The input into these variables is an integer value that represents the speed in μl/s that the pipettes dispense any given volume. The default dispense rates set by Opentrons are 300 μl/s, 50 μl/s, and 10 μl/s for the P300, P50, and P10 respectively. Note, the dispense rate also corresponds to the speed of the ‘blow_out’ action used during the Allot function.  This parameter is useful for finessing pipette dispensing behaviour. If there is a lot of splashing, lowering the dispense rate may help eliminate it.If a pipette is not dropping a volume that should be within its range, increasing the dispense rate can help push it out. Note however, that increasing the dispense rate won’t help at a certain point. For example, with the P10, increasing the dispense rate will not cause very small volumes to drop as the droplets would rather swing up the side of the tip than fall at very high dispense rates.There is no documented maximum or minimum rate that you can ask of the pipettes by Opentrons. 
	The small volume condition is set by the parameter ‘small_condition’ that takes an integer input that refers to the greatest volume in μl considered to meet the small volume condition. Volumes equal to and smaller than this small condition are treated differently in the Allot function. It is assumed that the P10 pipette will be unable to drop volumes equal to or smaller than the small condition with normal dispensing methods. To account for this, the P10 dips closer to the surface of the plate in order to have the droplet touch the surface and fall off the tip.


**Creating Containers**

Before using a container in a protocol, it must first be created and registered in the Opentrons software. This is done using the Opentrons-built ‘labware.create()’ function. In the Opentrons API, it is recommended to place the labware.create() function inside a try-except block. This way, if there is an error creating a container, it will not prevent the remainder of the code from running. Use of the labware.create() function looks as follows:

try:
custom_container = labware.create(
'container_1',           # name of your container
grid=(8, 8),               # specify amount of (columns, rows)
spacing=(1,1),         # distances (mm) between each (column, row)
diameter=5,             # diameter (mm) of each well on the plate
depth=10.00)          # depth (mm) of each well on the plate
except IntegrityError:
pass

Note that the variable name ‘custom_container’ never needs to be referred to again. The labware.create() function is unique in the Opentrons API, in that after running a protocol that contains a labware.create() function once, the new container is remembered by the Robot for all future protocols under the name given in the function. Unfortunately, multiple runs of the labware.create() function for a container of the same name will not update the Robot’s memory of the container. For this reason, it is fine to leave the labware.create() function in the protocol even if no specifications are changed, as it will have no effect on the protocol.
	A key limitation of the labware.create() function if that it only allows for containers to be defined with consistent column and row spacing. Therefore, for containers like cups which has alternating column spacing, each subsection of the container with consistent spacing needs to be defined as individual containers. Further details on this special case are discussed in the next section. This limitation of the labware.create() function has been brought up with Opentrons and they have expressed some interest in making the spacing variable more flexible in the future.
If at any time the specifications of a container need to be updated, include the following line at the start of the Creating Containers section:

database.delete_container('container_1') 

followed by the labware.create() function to recreate the container under the new specifications. Note, the database.delete_container() function should not be used at the start of the protocol unless needed. Including the database.delete_container() function without changing the specifications of the given container causes the Robot to delete the calibration data for that container between the Calibration stage and the Run stage. 
Note: when defining a new tiprack, the name given to is must start with ‘tiprack-’ in order for the Robot to understand how it should be used. 

**Defining Current Containers** 

At the start of the protocol, the container types and their positions inside the robot need to be defined. For the product output plate, the Opentrons function used is ‘labware.load()’. For the rest of the containers, the Opentrons function used is ‘containers.load()’.
The container containing the solution for distribution is given the variable name ‘solutions’ and is defined as a 6-well plate in slot 3 of the Robot.
The trash bin is given the variable name ‘trash’ and is defined using Opentrons’ preexisting definition, ‘robot.fixed_trash’, which places it in slot 12 of the Robot.
The tiprack for the P300 is given the variable name ‘m300rack’ and is defined as the ‘opentrons-tiprack-300μl’ in slot 4 of the Robot.
The tiprack for the P50 is given the variable name ‘m50rack’ and is defined as the ‘tiprack-Fisher200μl’ in slot 7 of the Robot. 
The tiprack for the P10 is given the variable name ‘m10rack’ and is defined as the ‘tiprack-10μl’ in slot 1 of the robot. 

Before defining the output product container, the protocol checks to see the value of the variable container_choice, set during the User Input section. For the full alumina or half alumina plate, the output container is given the variable name ‘plate’ and is defined as the corresponding alumina plate in slot 2 of the Robot. For the metal cups well plate, the are four output containers defined. As described in the creating containers section, the spacing of the metal cups container necessitates that it be defined as 4 sub-containers. They are given the variable names ‘plate_1’, ‘plate_2’, ‘plate_3’, and ‘plate_4’ and are defined as ‘metal_cups_part1’, ‘metal_cups_part2’, ‘metal_cups_part3’, and ‘metal_cups_part4’ respectively, all in slot 6 of the Robot. For plates 2-4, in their definition is also specified the setting ‘share=True’ which tells the Robot that all four plates can simultaneously exist in the same slot. 

**Defining Current Pipettes**

While defining the pipettes for a protocol, the goal of this section is also to determine which of the two loaded pipettes are larger. The section begins by first defining the variable ‘large_min_volume’, which will be specified based on the pipette later in the section.
First, the pipette on the left mount is defined. The protocol checks to see what pipette is loaded on the left mount by checking the first entry in the current_pipettes array from the User Input section. If the pipette is the P300, is it automatically set as the ‘large_pipette’, then the variable ‘large_min_volume’ is set to the ‘P300_min_volume’ variable from the User Input section. If the pipette is the P50, the protocol then checks if it is greater than or smaller than the other pipette listed in the current_pipettes array, and defines the P50 as either the ‘large_pipette’ or ‘small_pipette’ consequently. If the P50 is the larger pipette, then ‘large_min_volume’ is set to the ‘P50_min_volume’ variable from the User Input section. If the pipette is the P10, it is automatically set as the ‘small_pipette’. Note: the way this section is set up does not support two pipettes of the same type mounted on the Robot at the same time.
	After the protocol has established whether the left pipette is the large or small pipette, is defines its settings according to its size: P300, P50, or P10, using the Opentrons function ‘instruments.P300_single()’, ‘instruments.P50_single()’, or ‘instruments.P10_single()’. Inside this function, all the pipette settings are established corresponding to its size. For example, if the left pipette was the P50, the settings would be:
instruments.P50_single(
		mount = “left”,  
		dispense_flow_rate = P50_dispense_rate, 
		tip_racks = [m50rack], 
trash_container = trash  

where the P50_dispense_rate variable is defined in the User Input section. The same process is repeated for the pipette on the right mount, defined by the second entry in the current_pipettes array from the User Input section.

***Functions***

**Allot**

The Allot function is responsible for the basic aspirate and dispensing tasks. Input: pipette, volume, solution, destination well, iteration of solution_run_through (‘i’), small volume condition
First, it asks the pipette to aspirate the specified volume from the specified solution. Then, for every μl of volume aspirated, it asks the pipette to dispense 1 μl at a time at a height of 6mm above the plate or well bottom. Note that in case of a decimal volume specified, the volume is rounded up to the nearest integer. The Robot then pauses action for 0.1s to increase the chance that any volume clinging to the pipette tip will fall of its own accord. Next, the pipette performs a ‘blow_out’ action, which consists of the pipette pushing out air from the pipette tip to try to cause any volume clinging to the tip to fall.
	After all of these tasks have been performed, the protocol checks to see if the volume specified is equal to or less than the small volume condition, set in the User Input section. If the volume is within the small volume condition, this implies that the previous actions probably will have failed to get the volume to fall from the pipette tip. Therefore if this condition is met, it asks the pipette to lower down to a height of 0.5mm from the top of the plate or well bottom. The idea here is that by lowering the pipette, the volume clinging to the tip will touch the plate and transfer onto it. The protocol then checks if the volume specified is equal to 3 μl or smaller. If so, then it is likely that lowering to a height of 0.5mm is not sufficient to cause the volume to touch the surface. The pipette is then asked to move to a height of 0 mm above the plate or well bottom. Note: the pipette tip should never actually touch the surface of the plate or well bottom, even when asking it to drop to the surface. During calibration, the height of the pipette over the surface is always calibrated to be slightly above the surface. 

**Non-constant volume procedure**

The non-constant volume procedure function is responsible for the actions required for distributing a volume when its part of a gradient. Input: small pipette, large pipette, the boolean value describing if this iteration of solution_run_through (‘small_volume’), the boolean value describing if this well has a volume that meets the small volume condition (‘less_than_crit_well’), the volume, the large pipette minimum volume, the solution position, the destination well position, and the small volume confidition.
First, the protocol checks if the specified volume corresponds to the type of volumes being distributed in this iteration of the solution_run_through function: either small volumes or regular volumes.  If yes, then the protocol checks whether the specified volume is appropriate for the large or small pipette. Note: If the volume is specifically 0 μl, it specifies that no actions should be taken. Then, it runs the Allot function for the appropriate pipette and the specified volume.

**Checkerboard**

The checkerboard function is responsible for the actions required to distribute a checkerboard solution distribution. Input: pipette, volume, output container, destination well position, small volume condition, parity of the checkerboard distribution. 
	First, the protocol checks the parity of this checkerboard distribution. If the distribution is even or odd, builds the empty ‘behaviour’ array to specify how the distribution should act in even or odd wells. Following this, the protocol checks the output container type. If the output container is the full alumina plate, distributes through a range of 8 columns. If the output container is the half alumina plate, distributes through a range of 4 columns. If the output container is the cups well plate, distributes through 2 columns for each of the 4 sub-containers.
For every output container type, the protocol cycles through the columns and for each column asks whether it is even or odd. In an even column, it runs the Allot function for the well described by ‘behaviour[0]’. In an odd column, it runs the Allot function for the well described by ‘behaviour[1]’. This effectively enforces the parity of the distribution by dispensing into only even or odd wells in the even or odd columns corresponding to the parity.

**Solution run-through**

The ‘solution_run_through’ function is responsible for the bulk of organizing the protocol, particularly for dealing with the different distribution types. Input: small pipette, large pipette, output container, ‘small_volume’ boolean that describes whether the current iteration of solution_run_through is for small volumes or regular volumes, the small volume condition, the solution positions array, the list of solutions array, and the solution container. The function is built as one large for loop, iterating for each individual solution. 
	For the ith solution, the function first assigns the variable ‘position’ with the ith entry into the solution position array and sets the boolean ‘less_than_crit’ (which describes whether a volume meets the small volume condition) to False initially. Next the function asks what distribution type this solution has, which is recorded as the length of the ith solution array inside the list of solutions. The function then enters the section of the script specifically for that distribution type. This solution array is the original array created for the solution in the User Input section. Note that the way of differentiating between distribution type being length of the array is arbitrary, and differentiating by some string value could just as well be done.

**Constant volume**

For a constant volume distribution, the function first obtains the specified volume for the distribution, recorded in the first element of this solution’s array: ‘list_of_solutions[i][0]’. The function then asks if this volume meets the small volume condition. If it does, it sets the boolean ‘less_than_crit’ to True. Next, the function checks if the type of volume specified, small or regular, fits the volume type this iteration of solution_run_through is meant to distribute. If it does not, then the function does not distribute this solution. If it does match the volume type for this iteration, it goes on to ask what the appropriate pipette is for the volume using the ‘large_min_volume’ variable defined during the pipette defining stage of the script.  It then asks the appropriate pipette to pick up a tip. Next, the function asks what output container is being used. The output container being used changes the number of wells that need to be distributed to. For the chosen output container, we then run the Allot function with the same input parameters for every well. Once distribution is over, the function asks the pipette that was used for this solution to throw away its tip. 

**Checkerboard**

For a checkerboard distribution, the function will first obtain the specified volume recorded in the first element of this solution’s array: ‘list_of_solutions[i][0]’. It then checks if this volume meets the small volume condition or not. If it meets the small volume condition, it sets the ‘less_than_crit’ boolean to True. The function then checks if the volume type (small or regular) meets the volume type specified for this iteration of solution_run_through. If it does not, then it skips this solution this iteration of ‘sol_run_through’. Otherwise, the function goes on to decide on the appropriate pipette for this volume based on the pipette minimum volumes set in the User Input section. It then asks the appropriate pipette to pick up a tip. It then runs the checkerboard distribution function for the specified parity in the User Input section. After all of the solution has been distributed, it asks the pipette to drop its tip into the trash. 

**1D Gradient**

For a 1D solution gradient, the function starts by obtaining the starting and ending volumes, contained in the first and second elements of this solution’s array. With these starting and ending volumes, a volume step size is calculated, assuming that the gradient is over 8 wells. With the step size, an array of the individual well volumes across the gradient is built. Next, the goal is to record if any of these individual well volumes meet the small volume condition. For every volume along the gradient, the boolean ‘less_than_crit’, which describes if a volume does or does not meet the small volume condition, is set. Additionally, for each well the ‘less_than_crit’ value is saved in a ‘less_than_crit_array’.  Both the array and singular boolean value are used later.
	Next, the function checks which direction the gradient goes across the plate. This is recorded in the third element in this solution’s array: list_of_solutions[i][2]. Before going any further, the function asks if any of this volume gradient, whether regular or small volume, matches the type of volume being distributed by this iteration of the solution_run_through function. This makes use of the less_than_crit singular value, which will be True if any of the volumes meet the small_volume condition. If none of the volume gradient fits into the volume type being distributed this iteration, the solution is skipped. 
However if some or all of the volume gradient should be distributed this iteration, the next step is to decide upon the appropriate pipette(s). This is done by checking if the maximal and minimal values of the gradient against the large pipette minimum volume, set in the User Input section. If at any point in the gradient, a pipette is the appropriate on to use, that pipette will be told to grab a tip. Thus if the volume gradient goes over the range of both pipettes, both pipettes will have grabbed a tip. 
Next, the function uses the gradient direction variable set earlier in the 1D gradient section to decide which set of Robot instructions this solution requires. If the gradient is along the x direction, then the wells in the output container are referred to by:

container.rows(j).wells(k)

But if the gradient is along the y direction, then the wells in the output container are referred to by:
container.cols(j).wells(k)

This allows the function to iterate through the gradient well volume array using the iterative variable ‘k’ for either direction.
For each direction, the function also checks to see which output container is being used. Specifically if the output container is the half alumina plate and the gradient is in the x direction, the volume gradient range calculated before is invalid. A volume gradient over only four wells need to be calculated instead, including a new volume step size between wells. For the cups type output container, the script must iterate through the wells of all four sub-containers. 
Then, for every well, the function runs the ‘nonconstant_vol_procedure’ function to appropriately distribute the volume. Finally, the function performs the same check to see if any of the volume gradient steps are appropriate for the small or large pipette, and if a step was distributed by one of the pipettes, it asks that pipette to drop its tip. This ensures that only the pipettes used in the procedure are asked to drop a tip. 

**2D Gradient**

For a 2D gradient, the function starts by asking for the starting and ending volumes of the gradient, recorded in the first and second elements of this solutions’ array. Then, the change in volume between adjacent wells is calculated as ‘step’. Using this, an array is built containing every individual volume across a gradient of 15 wells. Next, the function goes through every volume value in this gradient and assesses if it meets the small volume condition. If it meets the small volume condition, it sets the boolean ‘less_than_crit’ to True and adds this result to a boolean array, ‘less_than_crit_array’. Both the singular less than crit boolean and the array are used later. 
Before continuing, the function checks if any of the volumes in the gradient fit the category being distributed by this iteration of the solution_run_through function, either small or regular volume. If none of the individual volumes match the distribution category this iteration, the solution is skipped. Otherwise, the next step is to decide on the appropriate pipette(s). By checking the maximum and minimum values of the gradient, we check if it is every appropriate to use the large or small pipette, using the large pipette minimum volume set in the User Input section. If one of the pipettes is every appropriate to use, it is told to pick up a tip. 
Next, the function asks what output container is being used. The different output containers have different number of wells or sub-containers, and thus require their own instructions. Note, the half alumina plate container cannot be used for the 2D gradient distribution type, since it requires an 8-by-8 plate to create a symmetric distribution. Then for every well in the output container, we run the ‘nonconstant_vol_procedure’ to distribute the correct volume in this place in the gradient. The volume for the well in the jth column and the kth row is associated with the j+kth volume in the gradient. This creates the symmetric 2D gradient. Once all of the distribution is complete, the function once again checks if either of the pipettes were appropriate to distribute any of the volumes in the gradient. If we find that a pipette was appropriate at some point, we know that we must have used it in the distribution, and thus we ask it to drop its pipette tip.


**Parallelogram**

The parallelogram distribution type is created in order to build part of a ternary diagram, namely a parallelogram-shaped slice. To create a distribution corresponding to a parallelogram in a ternary diagram, start with four solutions corresponding to the four corners of the parallelogram. Point each of their distributions in the direction from their corner of the parallelogram and towards the opposite corner. The distribution volume per well for the direction (1,-1) as shown in Table 1 is calculated as: well(j,k) = total - (total/7)col(j) - ((total-(total/7)col(j))/7)row(k), where j is the column number and k is the row number.
	In the coding for a parallelogram distribution function, we start by checking the start and end volumes of the gradient. Using these values, we build a two-dimensional array of volumes for each well defined by the parallelogram distribution. The function that checks to see if any of the individual well volumes meet the small volume condition. If they do, the boolean ‘less_than_crit’ is set to True and the two-dimensional array ‘less_than_crit_array’ is also set to True for the array element corresponding to that well. Next, the function records the specified direction of the distribution as an array made from the third and fourth element of this solutions’ array. 
	Before progressing any further, the function checks to see if any of the individual well volumes matches the volume category being distributed during this iteration of the solution_run_through function, either small volume or regular. If none of the individual volumes match the volume category for this iteration, the solution is skipped. Otherwise, the function moves on to decide on the appropriate pipette(s). If the maximum and minimum volume values are appropriate for one pipette over another based on the large pipette minimum volume setting, the appropriate pipette is asked to pick up a tip. 
	Next, the function considers the direction of the gradient. The four-different directions of the parallelogram distribution requires different instructions on how to map the two dimensional volumes array to the wells on the plate. For each direction, the function checks the output container. If the output container is cups, then the volume is distributed to the four sub-containers. Note: the half alumina plate cannot be used for this type of distribution as the volume steps are only calculated for an 8-by-8 plate. Finally, we call the ‘nonconstant_vol_procedure’ function to distribute the appropriate volume into the appropriate well. Once all of the volume has been distributed, the function checks which pipettes have been appropriate for this distribution, and asks all pipettes that were appropriate at any point to drop their tip into the trash.

**Protocol**

The protocol function is the core function run by the robot. This function is executed by the last line in the file: 
protocol(**{})

There is no input to this function. The protocol starts by defining some variables used later in the script, such as the ‘list_of_solutions’ array, and the ‘solution_pos’ array. Next, the protocol checks the entries of the solution arrays in the User Input section. For all solution arrays not left empty, it records the solution name in the list_of_solutions array and the solution position in the solution well plate in the solution_pos array. In the 6-well plate, solution_A is defined as being in well A1, solution_B is defined as being in well B1, solution_C is defined as being in well A2, solution_D is defined as being in well B2, and the precipitator is defined as being in well A3. 
	Once these arrays are built, the goal is to first distribute any solution volumes below the small volume condition. Since distributing small volumes requires the pipette tip to drop low to the surface of the plate, the protocol chooses to distribute all small volumes first in order to avoid cross contamination at the pipette tip. In order to do this, we start by creating a ‘small_volume’ boolean and setting it to True. Then, we run the solution_run_through function for small_volume = True. This goes through the distribution of all small volumes. Next, we set small_volume = False and run the solution_run_through function again for the new value of small_volume. 

**Errors and Misuse**

Many of the ways in which our protocol can be used incorrectly do not raise errors and thus may not be noticed until watching the Robot execute the actions. One of the reasons for this is that regular forms of scripted output that would relay errors or misuse to the user can’t be used when uploaded to the Opentrons App. For example, scripted output of strings are not relayed in the Opentrons App as they are not an executable function for the Robot. While the Opentrons App will announce any basic scripting errors when uploading the protocol, often there is no way of knowing if the protocol will perform as you expect until you see the Robot executing the actions. One method of learning how the App has interpreted the protocol before asking the Robot to execute those actions is by looking at the list of executable actions in the Run tab of the App after the calibration process.
	This barrier to building in failsaves is part of the motivation for creating a User Input section at the top of the protocol that can hopefully condenses sources of error and any accidental edits to the script. 

**Citations**

(1) opentrons; Opentrons: Brooklyn, NY, 2018.
